"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["540936"],{732527:function(n,e,i){n.exports=i.p+"static/image/weaving.422fab53.png"},61603:function(n,e,i){i.r(e),i.d(e,{default:()=>l});var s=i("110239"),t=i("444827"),r=i("732527");let c=i.p+"static/image/ecs.19f1ae29.png";function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",div:"div",ul:"ul",li:"li",h2:"h2"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"ecs",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#ecs",children:"#"}),"ECS"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"切面编程",src:r})}),"\n",(0,s.jsx)(e.p,{children:"理想的切面编程"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:"",children:"- myAppliation 提供业务逻辑\n  - service 特定的业务逻辑服务\n     - customDomainLogicService\n  - contributionImplement 钩子的注册实例化\n    - MyApplicationContributionImpl\n  - component 业务组件\n\n- core 提供通用逻辑\n  - model 通用模型\n  - contribution 钩子接口\n     - LifecycleContribution 应用的生命周期\n     - CommandContribution\n  - service 公用的service的服务\n     - CommandService\n     - ClipboardService\n  - component 公用的组件\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:"",children:"// IOC 的注入\n@injectable()\nexport class CustomDomainLogicService {\n@inject(FlowContextService) protected flowContextService: FlowContextService;\n@inject(CommandService) protected commandService: CommandService;\n@inject(SelectionService) protected selectionService: SelectionService;\n}\n// IOC 的接口声明\ninterface LifecycleContribution {\n onInit(): void\n onStart(): void\n onDispose(): void\n}\n// IOC 的接口实现\n@injectable()\nexport class MyApplicationContributionImpl implement LifecycleContribution {\n  onStart(): void {\n    // 特定的业务逻辑代码\n  }\n}\n\n// 手动挂在到生命周期钩子\nbind(LifecycleContribution).toService(MyApplicationContributionImpl)\n"})}),"\n",(0,s.jsxs)(e.div,{className:"rspress-directive warning",children:[(0,s.jsx)(e.div,{className:"rspress-directive-title",children:"IOC是切面编程的一种手段，引入后，底层模块可以以接口形式暴露给外部注册，带来的好处："}),(0,s.jsx)(e.div,{className:"rspress-directive-content",children:(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"实现微内核 + 插件化的设计，实现插件的可插拔按需消费"}),"\n",(0,s.jsx)(e.li,{children:"可以让包拆得更干净，实现 feature 式的拆包"}),"\n"]})})]}),"\n",(0,s.jsxs)(e.h2,{id:"为什么需要-ecs",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要-ecs",children:"#"}),"为什么需要 ECS"]}),"\n",(0,s.jsxs)(e.div,{className:"rspress-directive warning",children:[(0,s.jsx)(e.div,{className:"rspress-directive-title",children:"ECS （Entity-Component-System）"}),(0,s.jsx)(e.div,{className:"rspress-directive-content",children:(0,s.jsx)(e.p,{children:"\n适合解耦大的数据对象，常用于游戏，游戏的每个角色（Entity）数据都非常庞大，需要拆分成如物理引擎相关数据、皮肤相关、角色属性等 (多个 Component)，供不同的子系统（System）消费。流程的数据结构复杂，很适合用ECS做拆解"})})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"ECS",src:c})}),"\n",(0,s.jsx)(e.p,{children:"ReduxStore 伪代码"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",meta:"pure",children:"const store = () => ({\n  nodes: [{\n    position: any\n    form: any\n    data3: any\n\n  }],\n  edges: []\n})\n\nfunction Playground() {\n  const { nodes } = useStore(store)\n\n  return nodes.map(node => <Node data={node} />)\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"优点："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"中心化数据管理使用简单"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"缺点："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"中心化数据管理无法精确更新，带来性能瓶颈"}),"\n",(0,s.jsx)(e.li,{children:"扩展性差，节点新增一个数据，都耦合到一个 大JSON 里"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"ECS 方案\n备注："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"NodeData 对应的是 ECS - Component"}),"\n",(0,s.jsx)(e.li,{children:"Layer 对应 ECS - System"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",meta:"pure",children:"class FlowDocument {\ndataDefines: [\n  NodePositionData,\n  NodeFormData,\n  NodeLineData\n]\nnodeEntities: Entity[] = []\n}\n\n\nclass Entity {\nid: string // 只有id 不带数据\ngetData: (dataId: string) => EntityData\n}\n\n// 渲染线条\nclass LinesLayer {\n@observeEntityData(NodeLineData) lines\nrender() {\n  return lines.map(line => <Line data={line} />)\n}\n}\n\n// 渲染节点位置\nclass NodePositionsLayer {\n@observeEntityData(NodePositionData) positions\nreturn() {\n\n}\n}\n\n// 渲染节点表单\nclass  NodeFormsLayer {\n  @observeEntityData(NodeFormData) contents\nreturn() {}\n}\n\nclass Playground {\nlayers: [\n  LinesLayer, // 线条渲染\n  NodePositionsLayer, // 位置渲染\n  NodeFormsLayer // 内容渲染\n]，\nrender() {\n  return this.layers.map(layer => layer.render())\n}\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"优点："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"节点数据拆开来单独控制渲染，性能可做到精确更新"}),"\n",(0,s.jsx)(e.li,{children:"扩展性强，新增一个节点数据，则新增一个 XXXData + XXXLayer"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"缺点："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"有一定学习成本"}),"\n"]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(a,n)})):a(n)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["zh%2Fguide%2Fconcepts%2Fecs.mdx"]={toc:[{id:"为什么需要-ecs",text:"为什么需要 ECS",depth:2}],title:"ECS",frontmatter:{}}}}]);